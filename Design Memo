Design Memo: Social Network Graph Project

The Social Network Graph Project was developed to simulate how relationships form and interact within a social network using a graph data structure in Python. Each individual in the network is represented as a node, and each friendship is modeled as a bidirectional edge connecting two nodes. This design reflects real-world social systems, where relationships are mutual and dynamic. The purpose of the project is to demonstrate object-oriented programming concepts while implementing a graph that can grow, adapt, and manage user interactions efficiently.

The system is organized around two main classes: the Person class and the SocialNetwork class. This modular structure ensures clarity, scalability, and a clean separation of responsibilities between data representation and network management. The Person class represents an individual user. Each person has a name and a list of friends, which are stored as references to other Person objects. This structure allows friendships to be easily formed and navigated, much like an adjacency list in a graph. The add_friend() method prevents duplicate friendships by checking if a friend already exists in the list, ensuring that relationships remain accurate and consistent.

The SocialNetwork class acts as the central manager for all people and their connections. It maintains a dictionary, where each key is a user’s name and each value is a corresponding Person object. This setup allows for quick lookups and efficient management of users. The class provides methods to add new people, create friendships, and print the current network structure. The add_friendship() method ensures that friendships are bidirectional, meaning that when one person becomes friends with another, both individuals’ friend lists are updated simultaneously. Error handling is also built into this method: if either user does not exist in the network, the program alerts the user instead of failing silently. This makes the system more reliable and user-friendly.

A major strength of this design is its error prevention and data integrity. The network checks for duplicate users when adding new people and prevents connections between non-existent users. This attention to data validation ensures that the network structure always reflects valid, real-world scenarios. Moreover, by separating individual and network responsibilities across two classes, the program becomes easier to extend. Future improvements—such as suggesting friends, finding mutual connections, or measuring network size—can be added without rewriting the foundational code.

When tested, the program correctly builds and displays the network. For example, adding users such as Alex, Jordan, and Morgan and connecting them creates a network where Alex is friends with both Jordan and Morgan, and those relationships are reflected on both sides. Attempting to connect Jordan to Taylor, who does not exist, results in a clear error message rather than a crash. The print_network() method outputs a clear summary of each user and their connections, mirroring how social network platforms display user relationships.

Overall, the Social Network Graph project demonstrates key programming and data structure principles including encapsulation, modularity, and graph-based modeling. It effectively shows how Python’s object-oriented features can be used to simulate real-world relationships in a logical and scalable way. This project not only fulfills its functional goals but also lays a solid foundation for expanding into more advanced features such as friend recommendations, network visualization, and connection analysis. The design’s balance of simplicity, efficiency, and error control makes it an excellent example of practical, well-structured software engineering.
